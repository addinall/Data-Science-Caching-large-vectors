OK.  I'll go and look at the videos this weekend (what is left of it!).  I did look at the assignment two and the mean - vector implementations and to be perfectly honest, I couldn't figure out what they were doing.

makeVector <- function(x = numeric()) {
        m <- NULL                            ## this is an internal scope variable m?
        set <- function(y) {
                x <<- y                      ## this is modifying x upstream from this environment with y?
                m <<- NULL                   ## this is modifying an upstream m, the one we just declaredi in MakeVector?
        }
        get <- function() x                  ## without any comment this next lot just means(sic) nothing
        setmean <- function(mean) m <<- mean ## m upstream from makeVector being modified?
        getmean <- function() m              ## implicit return local m?
        list(set = set, get = get,           ## not a clue???? set = set, get = get???
             setmean = setmean,
             getmean = getmean)
}

I sorta get the idea but that is really tortured.  What is all the "set = set" about?

Anyway, I'll watch the movies!

On a *NIX system it has always been traditional to allocate 2-3 time much swp as DRAM.  The kernel uses this AS DRAM without the application being aware if it is being fed from silicon or disk.  That's what the paging does.  Setting the amount of swap is
not in concrete.  Sometime when I have had to run an intensive application on a tichy machine, I have upped the swap to
10 time the DRAM.  Slowish, but it fits.

Cheers,
Mark.

